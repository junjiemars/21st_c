#+TITLE: C Lessons
#+AUTHOR: Junjie Mars
#+STARTUP: overview


[[https://api.travis-ci.org/junjiemars/c][https://api.travis-ci.org/junjiemars/c.svg?branch=master]]

It is not /C Lessons/ at all :). I'd programming in C long long time ago, 
sometimes I want to pick something up, but I cannot find the peice of code 
somewhere or cannot run the code on a machine that been wrote in another machine. 

Sadly, old dog need learn something new
- Access the code from anywhere, oh, GitHub is good one
- Run or write code on anywhere, so Linux, Darwin, or Windows, Docker Box
- Easy to try and learn something new

Now, we had [[https://github.com/junjiemars/nore][Nore]], something changed and 
something not.


Let's start ...

#+BEGIN_SRC sh
# <where> to put nore down
$ PREFIX=<where> bash <(curl https://raw.githubusercontent.com/junjiemars/nore/master/bootstrap.sh)

# configure -> make -> install
$ ./configure --has-hi
$ make
$ make install

# update nore, <what> you want to make
$ ./configure --update --has-<what>
#+END_SRC

* Hello World
* Language
	:PROPERTIES:
	:CUSTOM_ID: language
	:END:

** Preprocessor	
	 :PROPERTIES:
	 :CUSTOM_ID: language_perprocessor
	 :END:

*** #include
		:PROPERTIES:
		:CUSTOM_ID: language_preprocessor_include
		:END:
		
The =#include= directive instructs the preprocessor to paste the 
text of the given file into the current file. 
Generally, it is necessary to tell the preprocessor where to look for 
header files if they are not placed in the current directory 
or a standard system directory. 

*** #define
		:PROPERTIES:
		:CUSTOM_ID: language_preprocessor_define
		:END:

The =#define= directive takes two forms: defining a /constant/ 
and creating a /macro/. 

- Defining a /constant/
#+BEGIN_SRC c
#define identifier [value]
#+END_SRC

When defining a /constant/, you may optionally elect not to provide 
a value for that constant. In this case, the /identifier/ 
will be replaced with blank text, but will be "defined" for the 
purposes of =#ifdef= and =ifndef=. If a value is provided, 
the given token will be replaced literally with the remainder of 
the text on the line. You should be careful when using =#define=
in this way.

- Defining a /parameterized macro/
#+BEGIN_SRC c
#define identifier(<arg> [, <arg>s ...]) statement

#define MAX(a, b) ((a) > (b) ? (a) : (b))
#+END_SRC


*** #undef
		:PROPERTIES:
		:CUSTOM_ID: language_preprocessor_undef
		:END:


#+BEGIN_SRC c
#undef identifier
#+END_SRC

The =#undef= directive undefines a constant or preprocessor macro 
defined previously using #define.

For example:

#+BEGIN_SRC c
#define E 2.71828
double e_squared = E * E;
#undef E
#+END_SRC

Usually, =#undef= is used to scope a preprocessor constant into 
a very limited region: this is done to avoid leaking the constant.
=#undef= is the only way to create this scope since the preprocessor 
does not understand block scope. 


*** #if vs. #ifdef
		:PROPERTIES:
		:CUSTOM_ID: language_preprocessor_if_vs_ifdef
		:END:

		=#if= check the value of the symbol, =#ifdef= just check the 
existence of the symbol.

Prefer =#if define(...)=, it's more flexible
#+BEGIN_SRC c
#if defined(LINUX) || defined(DARWIN)
/* code: when on LINUX or DARWIN platform */
#endif

#if defined(CLANG) && (1==NM_HAVE_LITTLE_ENDIAN)
/* code: when using clang compile and on little endian machine */
#endif
#+END_SRC

*** #ifndef
		:PROPERTIES:
		:CUSTOM_ID: language_preprocessor_ifndef
		:END:


#+BEGIN_SRC c
#ifndef identifer
/* code: when the identifier had not been defined */
#endif
#+END_SRC

=#ifndef= checks whether the given identifier has been =#defined= earlier 
in the file or in an included file; if not, it includes the code 
between it and the closing =#else= or, if no =#else= is present, 
=#endif= statement. =#ifndef= is often used to make header files idempotent 
by defining a identifier once the file has been included and checking 
that the identifier was not set at the top of that file.

#+BEGIN_SRC c
#ifndef  _LANG_H_
# define  _LANG_H_
#endif
#+END_SRC

=#if !defined(identifier)= is equivalent to =#ifndef identifier=

#+BEGIN_SRC c
#if !defined(MIN)
# define MIN(a, b) ((a) < (b) ? (a) : (b))
#endif
#+END_SRC

*** #error	 
		:PROPERTIES:
		:CUSTOM_ID: language_preprocessor_error
		:END:

#+BEGIN_SRC c
#error "[description]"
#+END_SRC

The =#error= macro allows you to make compilation fail and issue a statement
 that will appear in the list of compilation errors. It is most useful 
when combined with =#if/#elif/#else= to fail compilation if some condition 
is not true. For example:

#+BEGIN_SRC c
#if (1==_ERROR_)
# error "compile failed: because _ERROR_==1 is true"
#endif
#+END_SRC

*** #pragma
		:PROPERTIES:
		:CUSTOM_ID: language_preprocessor_pragma
		:END:
		
The =#pragma= directive is used to access compiler-specific preprocessor extensions. 


A common use of =#pragma= is the =#pragma= once directive, which asks 
the compiler to include a header file only a single time, no matter 
how many times it has been imported.

#+BEGIN_SRC c
#pragma once
/* header file code */

/* #pragma once is equivalent to */
#ifndef  _FILE_NAME_H_
# define  _FILE_NAME_H_
/* header file code */
#endif
#+END_SRC

The =#pragma= directive can also be used for other compiler-specific purposes. 
=#pragma= is commonly used to suppress warnings.

#+BEGIN_SRC c
#if MSVC 
# pragma warning(disable:4706) /* assignment within conditional expression */
#elif GCC
# pragma GCC diagnostic ignored "-Wparentheses"
#elif CLANG
# pragma clang diagnostic ignored "-Wparentheses"
#endif
#+END_SRC


*** #__FILE__
		:PROPERTIES:
		:CUSTOM_ID: language_preprocessor_file
		:END:

- =__FILE__= expands to full path to the current file
- =__LINE__= expands to current line number in the source file, as an integer
- =__DATE__= expands to current date at compile time in the form
  =Mmm dd yyyy= as a string, such as "Tue Sep 25 2018"
- =__TIME__= expands to current time at compile time in the form
  =hh::mm::ss= in 24 hour time as a string, such as "16:08:17"
- =__TIMESTAMP__= hat expands to current time at compile time in the
  form =Ddd Mmm Date hh::mm::ss yyyy= as a string, where the time is
  in 24 hour time, =Ddd= is the abbreviated day, =Mmm= is the
  abbreviated month, =Date= is the current day of the month (1-31),
  and =yyyy= is the four digit year, such as ""

* x86
* Memory
	:PROPERTIES:
	:CUSTOM_ID: memory
	:END:

** Bits and Bytes
	 :PROPERTIES:
	 :CUSTOM_ID: memory-bits-and-bytes
	 :END:

*** Bits
		:PROPERTIES:
		:CUSTOM_ID: memory-bits-and-bytes-bits
		:END:

The smallest unit of memory is the /bit/. 
A bit can be in one of two states: =on= vs. =off=, 
or alternately, =1= vs. =0=.

Most computers don't work with bits individually, but instead group eight 
bits together to form a /byte/. Eash byte maintains one eight-bit pattern.
A group of N bits can be arranged in 2^N different patterns.

Strictly speaking, a program can interpret a bit pattern any way it chooses.

*** Bytes
	 :PROPERTIES:
	 :CUSTOM_ID: memory-bits-and-bytes-bytes
	 :END:

The byte is sometimes defined as the /smallest addressable unit/ of memory.
Most computers also support reading and writting larger units of 
memory: 2 bytes /half-words/ (sometimes known as a /short/ word) 
and 4 byte /word/.

Most computers restrict half-word and word accesses to be /aligned/: 
a half-word must start at an even address and a word must start at an 
address that is a multiple of 4.

*** Shift
		:PROPERTIES:
		:CUSTOM_ID: memory-bits-and-bytes-shift
		:END:

Logical shift always fill discarded bits with 0s while arithmetic shift fills it with
0s only for left shift, but for right shift it copies the Most Significant Bit
thereby preserving the sign of the operand.


Left shift on unsigned integers, =x << y=
- shift bit-vector =x= by =y= positions
- throw away extra bits on left
- fill with 0s on right

Right shift on unsigned integers, =x >> y=
- shift bit-vector =x= right by =y= positions
- throw away extra bits on right
- fill with 0s on left


Left shift, =x << y=
- equivalent to multiplying by 2^y
- if resulting value fits, no 1s are lost

Right shift, =x >> y=
- logical shift for unsigned values, fill with 0s on left
- arithmetic shift for signed values
  - replicate most significant bit on left
  - maintains sign of =x=
- equivalent to =floor(2^y)=
  -	correct rounding towards 0 requires some care with signed numbers.
  -	=(unsigned)x >> y | ~(~0u >> y)=

** Basic Types	
	 :PROPERTIES:
	 :CUSTOM_ID: memory-basic-types
	 :END:

*** Character
		:PROPERTIES:
		:CUSTOM_ID: memory-basic-types-character
		:END:

The ASCII code defines 128 characters and a mapping of those
characters onto the numbers 0..127. The letter 'A' is assigned 65 in the 
ASCII table. Expressed in binary, that's 2^6 + 2^0 (64 + 1). 
All standard ASCII characters have zero in the uppermost 
bit (the *most significant* bit) since they only span the range 0..127.


*** Short Integer 
		:PROPERTIES:
		:CUSTOM_ID: memory-basic-types-short-integer
		:END:


2 bytes or 16 bits. 16 bits provide 2^16 = 65536 patterns.
This number is known as /64k/, where /1k/ of something is 2^10 = 1024. 
For non-negative numbers these patterns map to the numbers 0..65535. Systems
that are /big-endian/ store the most-significant byte at the lower address. 
A /litter-endian/ (Intel x86) system arranges the bytes in the opposite 
order. This means when exchanging data through files or over a network 
between different endian machines, there is often a substantial amount of
/byte-swapping/ required to rearrange the data.

*** Long Integer 
		:PROPERTIES:
		:CUSTOM_ID: memory-basic-types-long-integer
		:END:

4 bytes or 32 bits. 32 bits provide 2^32 = 4294967296
patterns. 4 bytes is the contemporary default size for an integer. Also 
known as a /word/.


*** Floating Point 
		:PROPERTIES:
		:CUSTOM_ID: memory-basic-types-floating-point
		:END:

4,8, or 16 bytes. Almost all computers use the standard
IEEE representation for floating point numbers that is a system much more
complex than the scheme for integers. The important thing to note is that
the bit pattern for the floating point number 1.0 is not the same as the 
pattern for integer 1. IEEE floats are in a form of scientific notation.
A 4-byte float uses 23 bits for the mantissa, 8 bits for the exponent, and
1 bit for the sign. Some processors have a special hardware Floating Point
Unit, FPU, that substantially speeds up floating point operations.
With separate integer and floating point processing units, it is often 
possible that an integer and a floating point computation can proceed in
parallel to an extent. The exponent field contains 127 plus the true 
exponent for sigle-precision, or 1023 plus the true exponent for double
precision. The first bit of the mantissa is typically assumed to be 1._f_,
where *f* is the field of fraction bits.

|                  | sign     | exponent (base 2) | mantissa     |
|------------------+----------+-------------------+--------------|
| signle precision | 1 [31]   | 8 [30-23]         | 23 [22-00]   |
| double precision | 1 [63]   | 8 [62-52]         | 52 [51-00]   |

*** Record
		:PROPERTIES:
		:custom_id: memory-basic-types-record
		:END:

The size of a record is equal to at least the sum of the size
of its component fields. The record is laid out by allocating the components 
sequentially in a contiguous block, working from low memory to high. 
Sometimes a compiler will add invisible pad fields in a record to comply
with processor alignment rectrictions.

*** Array
		:PROPERTIES:
		:custom_id: memory-basic-types-array
		:END:

The size of an array is at least equal to the size of each element
multiplied by the number of components. The elements in the array are laid
out consecutively starting with the first element and working from low
memory to high. Given the base address of the array, the compiler can generate
constant-time code to figure the address of any element. As with records,
there may be pad bytes added to the size of each element to comply with
alignment retrictions.

*** Pointer 
		:PROPERTIES:
		:custom_id: memory-basic-types-pointer
		:END:

A pointer is an address. The size of the pointer depends on the
range of addresses on the machine. Currently almost all machines use 4 bytes
to store an address, creating a 4GB addressable range. There is actually
very little distinction between a pointer and a 4 byte unsigned integer.
They both just store integers-- the difference is in whether the number is 
/interpreted/ as a number or as an address.

*** Instruction
		:PROPERTIES:
		:custom_id: memory-basic-types-instruction
		:END:

Machine instructions themselves are also encoded using bit
patterns, most often using the same 4-byte native word size. The different
bits in the instruction encoding indicate things such as what type of 
instruction it is (load, store, multiply, etc) and registers involved.

** Pointer Basics
	 :PROPERTIES:
	 :custom_id: memory-pointer-basics
	 :END:

*** Pointers and Pointees
		:PROPERTIES:
		:custom_id: memory-pointer-basics-pointers-and-pointees
		:END:

We use the term *pointee* for the thing that the pointer points to,
and we stick to the basic properties of the pointer/pointee relationship
which are true in all languages.

Allocating a pointer and allocating a pointee for it to point to are two
separate steps. You can think of the pointer/pointee structure are operating
at two levles. Both the levels must be setup for things to work.


*** Dereferencing
		:PROPERTIES:
		:custom_id: memory-pointer-basics-dereferencing
		:END:

The *dereference* operation starts at the pointer and follows its arrow
over to access its pointee. The goal may be to look at the pointee state
or to change the state.

The dereference operation on a pointer only works if the pointer has a 
pointee: the pointee must be allocated and the pointer must be set to 
point to it.

*** Pointer Assignment
		:PROPERTIES:
		:custom_id: memory-pointer-basics-pointer-assignment
		:END:

*Pointer assignment* between two pointers makes them point to the same
pointee. Pointer assignment does not touch the pointees. It just changes
one pointer to have the same refrence as another pointer. After pointer
assignment, the two pointers are said to be /sharing/ the pointee.

** C Array
	 :PROPERTIES:
	 :custom_id: memory-c-array
	 :END:

A C array is formed by laying out all the elements contiguously 
in memory from low to high. 
The array as a whole is referred to by the address of the first element.


The programmer can refer to elements in the array with the simple =[]= syntax 
such as =intArray[1]=. This scheme works by combing the base address of 
the array with the simple arithmetic. 
Each element takes up a fixed number of bytes known at compile-time. 
So address of the _nth_ element in the array (0-based indexing) will be 
at an offset of =(n * element_size)= bytes from the base address of the whole 
array.


*** [] Operator
		:PROPERTIES:
		:custom_id: memory-c-array-[]-operator
		:END:

The square bracket syntax =[]= deals with this address arithmetic for you, but 
it's useful to know what it's doing. The =[]= multiplies the integer index by  
the element size, adds the resulting offset to the array base address, and finally
deferences the resulting pointer to get to the desired element.


#+BEGIN_SRC c
a[3] == *(a + 3);
a+3 == &a[3]; 

a[b] == b[a];
#+END_SRC


The C standard defines the =[]= operator as follows:
=a[b] => *(a+b)=, and =b[a] => *(b+a) => *(a+b)=, so =a[b] == b[a]=.


In a closely related piece of syntax, adding an integer to a pointer 
does the same offset computation, but leaves the result as a pointer. 
The square bracket syntax dereferences that pointer to access 
the /nth/ element while the =+= syntax just computes the pointer 
to the /nth/ element.


Any =[]= expression can be written with the =+= syntax instead. We just need 
to add in the pointer dereference. For most purposes, it's easiest 
and most readable to use the =[]= syntax. Every once in a 
while the =+= is convenient if you needed a pointer to the element 
instread of the element itself.


*** Pointer++
		:PROPERTIES:
		:custom_id: memory-c-array-pointer++
		:END:


If =p= is a pointer to an element in an array, then =(p+1)= points to the 
next element in the array. Code can exploit this using the construct =p++= to 
step a pointer over the elements in an array. It doesn't help readability any.


*** Pointer Type Effects
		:PROPERTIES:
		:custom_id: memory-c-array-pointer-type-effects
		:END:

Both =[]= and =++= implicitly use the compile time type of the pointer to 
compute the element size which effects the offset arithmetic. 


#+BEGIN_SRC c
	int *p;
	p = p + 12; /* p + (12 * sizeof(int)) */

	p = (int*) ((char*)p + 12); /* add 12 sizeof(char) */
#+END_SRC

Each =int= takes 4 bytes, so at runtime the code will effectively 
increment the address in =p= by 48. The compiler figures all this out 
based on the type of the pointer.


*** Arithmetic on a void pointer
		:PROPERTIES:
		:custom_id: memory-c-array-arithmetic-on-a-void-pointer
		:END:


What is =sizeof(void)=? Unknown! Some compilers assume that it should be 
treat it like a =(char*)=, but if you were to depend on this you would be 
creating non-portable code.

Note that you do not need to cast the result back to =(void*)=, a =(void*)= is
the /universal recipient/ of pinter type and can be freely assigned 
any type of pointer.


*** Arrays and Pointers
		:PROPERTIES:
		:custom_id: memory-c-array-arrays-and-pointers
		:END:

One effect of the C array scheme is that the compiler 
does not meaningfully distinguish between arrays and pointers.

*** Array Names are const
		:PROPERTIES:
		:custom_id: memory-c-array-array-names-are-const
		:END:

One subtle distinction between an array and a pointer, 
is that the pointer which represents the base address of an array 
cannot be changed in the code. Technically, the array base 
address is a =const= pointer. The constraint applies to 
the name of the array where it is declared in the code.


*** Dynamic Arrays
		:PROPERTIES:
		:custom_id: memory-c-array-dynamic-arrays
		:END:

Since arrays are just contiguous areas of bytes, you can allocate your 
own arrays in the heap using =malloc=. And you can change the size of 
the =malloc=ed array at will at run time using =realloc=.


*** Passing multidimensional arrays to a function
		:PROPERTIES:
		:custom_id: memory-c-array-passing-multidimensional-arrays-to-a-function
		:END:


*** Iteration
		:PROPERTIES:
		:custom_id: memory-c-array-iteration
		:END:

Row-major order, so load =a[0][0]= would potentially load =a[0][1]=, 
but load =a[1][0]= would generate a second cache fault.


*** Allocation
		:PROPERTIES:
		:custom_id: memory-c-array-allocation
		:END:


**** malloc
		:PROPERTIES:
		:custom_id: memory-c-array-allocation-malloc
		:END:

> Don't cast the result of malloc
> It is unneccessary, as =void *= is automatically and safely prompted to any
other pointer type in this case.
> It adds clutter to the code, casts are not very easy to read (especially if the
pointer type is long).
> It makes you repeat yourself, which is generally bad.
> It can hide an error, if you forgot to include =<stdlib.h>=. This can crashes 
(or, worse, not cause a crash until way later in some totally different part of the
code). Consider what happens if pointers and integers are differently sized; then
you're hiding a warning by casting and might lose bits of your returned address. 
Note: as of C11 implicit functions are gone from C, and this point is no longer 
relevant since there's no automatic assumption that undeclared functions return 
=int=

> To add further, your code needlessly repeats the type information (=int=) which
can cause errors. It's better to dereference the pointer being used to store the 
return value, to __lock__ the two together:
> =int *x = malloc(length * sizeof *x);=
> This also moves the =lengh= to the front for increased visibility, and drops
the redundant parentheses with =sizeof()=; they are only needed when the argument 
is a type name. Many people seem to not know or ignore this, which makes their code
move verbose. Remember: =sizeof= is not a function!

> While moving length to the front may increase visibility in some
rare cases, one should also pay attention that in the general case, 
it should be better to write the expression as:
=int *x = malloc(sizeof *x * length);=

> Compare with =malloc(sizeof *x * length * width)= vs. 
=malloc(length * width * sizeof *x)= the second may overflow the 
=length * width= when =length= and =width= are smaller types than 
=size_t=.

**** realloc
**** calloc

** Stack Implementation
	 :PROPERTIES:
	 :custom_id: memory-stack-implementation
	 :END:

Writing a generic container in pure C is hard, and it's hard for two reasons:

The language doesn't offer any real support for /encapsulation/ or 
/information hiding/. That means that the data structures expose information 
about /internal representation/ right there in the interface file 
for everyone to see and manipulate. The best we can do is document 
that the data structure should be treated as an abstract data type, 
and the client shouldn't directly manage the fields. Instead, he should just 
rely on the fuctions provided to manage the internals for him.

C doesn't allow data types to be passed as parameters. That means a generic 
container needs to manually manage memory in terms of the client element size, 
not client data type. This translates to a bunch of =malloc=, =realloc=, 
=free=, =memcpy=, and =memmove= calls involving =void*=.

** Endian
	 :PROPERTIES:
	 :custom_id: memory-endian
	 :END:

Endianness refers to the sequential order used to numerically interpret 
/a range of bytes/ in /computer memory/ as larger, composed word value.
It also describes the order of byte transmission over a **digital link**.

However, if you have a 32-bit register storing a 32-bit value, it makes no 
to talk about endianness. The righmost bit is the least significant bit,
and the leftmost bit is the most significant bit.


*** Big Endian
		:PROPERTIES:
		:custom_id: memory-endian-big-endian
		:END:

#+CAPTION: Big Endian
#+NAME: fig:big-endian
[[file:src/memory/big-endian.png]]


*** Little Endian
		:PROPERTIES:
		:custom_id: memory-endian-little-endian
		:END:

#+CAPTION: Little Endian
#+NAME: fig:little-endian
[[file:src/memory/little-endian.png]]


The little-endian system has the property that the same value can be read
from memory at different lengths without using different addresses. 
For example, a 32-bit memory location with content 4A 00 00 00 can be read
at the same address as either 8-bit (value = 4A), 16-bit (004A), 24-bit 
(00004A), or 32-bit (0000004A), all of which retain the same numeric value.

*** Bit Swapping
		:PROPERTIES:
		:custom_id: memory-endian-bit-swapping
		:END:

Some CPU instruction sets provide native support for endian swapping, 
such as /bswap/ (x86 and later), and /rev/ (ARMv6 and later).

Unicode text can optionally start with a /byte order mark/ (BOM) to 
signal the endianness of the file or stream. Its code point is *U+FEFF*. 
In UTF-32 for example, a big-endian file should start with =00 00 FE FF=; 
a little endian should start with =FF FE 00 00=.

Endianness doesn't apply to everything. If you do bitwise or bitshift 
operations on an int you don't notice the endianness.

TCP/IP are defined to be big-endian. The multi-byte integer representation 
used by the TCP/IP protocols is sometimes called /network byte order/.

In =<arpa/inet.h>=:
- =htons()= reorder the bytes of a 16-bit unsigned value from processor order
 to network order, the macro name can be read as "host to network short."
- =htonl()= reorder the bytes of a 32-bit unsigned value from processor order
	to network order, the macro name can be read as "host to network long."
- =ntohs()= reorder the bytes of a 16-bit unsigned value from network order to processor order,
	the macro name can be read as "network to host short."
- =ntohl()= reorder the bytes of a 32-bit unsigned value from network order to
 processor order. The macro name can be read as "network to host long

*** Tools
		:PROPERTIES:
		:custom_id: memory-endian-tools
		:END:

- =hexdump= on Unix-like system

** Memory Model
	 :PROPERTIES:
	 :custom_id: memory-memory-model
	 :END:

The only thing that C must care about is the type of the object 
which a pointer addresses. 
Each pointer type is derived from another type, its base type, 
and each such derived type is a distinct new type.

** References
	 :PROPERTIES:
	 :custom_id: memory-references
	 :END:

- [[https://stackoverflow.com/questions/7622/are-the-shift-operators-arithmetic-or-logical-in-c][Are the shift operators arithmetic or logical in C?]]
- [[https://en.wikipedia.org/wiki/Arithmetic_shift][Arithmetic shift]]
- [[http://stackoverflow.com/documentation/c/322/arrays#t=20170207121645271737][Arrays]]
- [[https://www.cs.umd.edu/class/sum2003/cmsc311/Notes/Data/endian.html][Big and Little Endian]]
- [[https://stackoverflow.com/questions/605845/do-i-cast-the-result-of-malloc][Do I cast the result of malloc]]
- [[https://en.wikipedia.org/wiki/Endianness][Endianness]]
- [[http://mjfrazer.org/mjfrazer/bitfields/][How Endianness Effects Bitfield Packing]]
- [[http://steve.hollasch.net/cgindex/coding/ieeefloat.html][IEEE Standard 754 Floating Point Numbers]]
- [[https://en.wikipedia.org/wiki/Logical_shift][Logical shift]]
- [[http://cslibrary.stanford.edu/106/][Pointer Basics]]
- [[https://see.stanford.edu/Course/CS107][Programming Paradigms]]
- [[https://stackoverflow.com/questions/4306186/structure-padding-and-packing][Structure padding and packing]]
- [[https://see.stanford.edu/materials/icsppcs107/07-Arrays-The-Full-Story.pdf][The Ins and Outs of C Arrays]]
- [[http://www.catb.org/esr/structure-packing/][The Lost Art of C Structure Packing]]
- [[https://betterexplained.com/articles/understanding-big-and-little-endian-byte-order/)][Understanding Big and Little Endian Byte Order]]
- [[https://www.ibm.com/developerworks/aix/library/au-endianc/index.html?ca=drs-)][Writing endian-independent code in C]]

* CPU
* POSIX
* Language
* Library
* String
* Unicode
* IO
* Network

** DNS
	 :PROPERTIES:
	 :CUSTOM_ID: network-dns
	 :END:

=simple.c= using =getaddrinfo()= API call to query name.

=query.c= using domain name protocol to query name directly without =-lresolv= library. 

*** TIL
		
- =getaddrinfo()= is a POSIX.1g extension and is not available in pure C99, 
on Linux, so We need =-D_GNU_SOURCE= if =-std=c99= be specified (see [[https://github.com/droe/sslsplit/issues/2][c99 does not define getaddrinfo]]).
- =socklen_t= represents the size of an address structure, see [[https://yarchive.net/comp/linux/socklen_t.html][Linus Torvalds talk about socklen_t]].

*** References
		:PROPERTIES:
		:CUSTOM_ID: dns-refrences
		:END:

- [[https://www.ietf.org/rfc/rfc1034.txt][RFC 1034: DOMAIN NAMES - CONCEPTS AND FACILITIES]]
- [[https://www.ietf.org/rfc/rfc1035.txt][RFC 1035: DOMAIN NAMES - IMPLEMENTATION AND SPECIFICATION]]
- [[https://tools.ietf.org/html/rfc1536][RFC 1536: Common DNS Implementation Errors and Suggested Fixes]]
- [[http://www.linuxhowtos.org/C_C++/socket.htm][Sockets Tutorial]]
	
