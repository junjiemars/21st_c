# -*- mode:sh -*- vim:ft=sh
#
# generated by Nore
#


# check machine features
#----------------------------------------
nm_feature="endian"
nm_feature_name="nm_cpu_little_endian"
nm_feature_indent=yes
nm_feature_run=value
nm_feature_h="#include <stdio.h>"
nm_feature_flags=
nm_feature_test='int i=0x11223344;
                 char *p = (char*)&i;
                 int le = (0x44 == *p);
                 printf("%d", le);'
. ${NORE_ROOT}/auto/feature


## check machine features
##----------------------------------------
case "$NM_SYSTEM" in
  Darwin)
    nm_feature="cache line size"
    nm_feature_name='nm_cpu_cache_line'
    nm_feature_indent=yes
    nm_feature_run=value
    nm_feature_h='#include <stdio.h>
    #include<sys/sysctl.h>'
    nm_feature_flags=
    nm_feature_value=
    nm_feature_test='
    size_t line = 0;
    size_t size = sizeof(line);
    if (!sysctlbyname("hw.cachelinesize", &line, &size, 0, 0)) {
       printf("%d\n", (int)line);
       return 0;
    }
    return 1;'
    . ${NORE_ROOT}/auto/feature
    if [ "yes" = "$nm_found" ]; then
      NM_CPU_CACHE_LINE=$nm_feature_value
    fi
    ;;
  Linux)
    nm_feature="cache line size"
    nm_feature_name='nm_cpu_cache_line'
    nm_feature_indent=yes
    nm_feature_run=value
    nm_feature_h='#include <stdio.h>'
    nm_feature_flags=
    nm_feature_value=
    nm_feature_test='
    FILE * p = fopen("/sys/devices/system/cpu/cpu0/cache/index0/coherency_line_size", "r");
    if (p) {
        int i = 0;
        fscanf(p, "%d", &i);
        fclose(p);
        printf("%d\n", i);
        return 0;
    }
    return 1;'
    . ${NORE_ROOT}/auto/feature
    if [ "yes" = "$nm_found" ]; then
      NM_CPU_CACHE_LINE=$nm_feature_value
    fi
    ;;
  WinNT)
    nm_feature="cache line size"
    nm_feature_name='nm_cpu_cache_line'
    nm_feature_indent=yes
    nm_feature_run=value
    nm_feature_h='#include <stdlib.h>
    #include <stdio.h>
    #include <windows.h>'
    nm_feature_flags=
    nm_feature_value=
    nm_feature_test='
    size_t line = 0;
    DWORD size = 0;
    SYSTEM_LOGICAL_PROCESSOR_INFORMATION *buf = 0;
    GetLogicalProcessorInformation(0, &size);
    if (!size) {
      return 1;
    }
    buf = (SYSTEM_LOGICAL_PROCESSOR_INFORMATION*)malloc(size);
    if (!buf) {
      return 1;
    }
    if (GetLogicalProcessorInformation(&buf[0], &size)) {
      for (DWORD i = 0; i != size/sizeof(SYSTEM_LOGICAL_PROCESSOR_INFORMATION); i++) {
        if (buf[i].Relationship == RelationCache && 1 == buf[i].Cache.Level) {
          line = buf[i].Cache.LineSize;
          break;
        }
      }
    }
    free(buf);
    if (line) {
      printf("%d\n", (int)line);
      return 0;
    }
    return 1;'
    . ${NORE_ROOT}/auto/feature
    if [ "yes" = "$nm_found" ]; then
      NM_CPU_CACHE_LINE=$nm_feature_value
    fi
    ;;
  *)
    nm_found=no
    ;;
esac
if [ "yes" = "$nm_found" ]; then
  NM_CPU_CACHE_LINE=$nm_feature_value
else
  case "$NM_MACHINE" in
    x86_64|amd64|ia64) NM_CPU_CACHE_LINE=64 ;;
    i386|i686|i86pc|*) NM_CPU_CACHE_LINE=32 ;;
  esac
  have=NM_CPU_CACHE_LINE value=$NM_CPU_CACHE_LINE . ${NORE_ROOT}/auto/define
fi # end of check cache line size


# check header files
#----------------------------------------
include="stdint.h" . ${NORE_ROOT}/auto/include
include="inttypes.h" . ${NORE_ROOT}/auto/include
include="stdbool.h" . ${NORE_ROOT}/auto/include


nm_feature="sizeof(void*)"
nm_feature_name="nm_ptr_len"
nm_feature_run=value
nm_feature_h="#include <stdio.h>"
nm_feature_flags=
nm_feature_test='void* p; printf("%zu", sizeof p);'
. ${NORE_ROOT}/auto/feature


nm_feature="sizeof(size_t)"
nm_feature_name="nm_size_t_len"
nm_feature_flags=
nm_feature_run=value
nm_feature_h="#include <stdio.h>"
nm_feature_flags=
nm_feature_test='printf("%zu", sizeof(size_t)*8);'
. ${NORE_ROOT}/auto/feature


nm_feature="variable-length array"
nm_feature_name="nm_have_vla"
nm_feature_flags=
nm_feature_run=no
nm_feature_h=
nm_feature_flags=
nm_feature_test='int size; int buffer[size];'
. ${NORE_ROOT}/auto/feature


# check features based on OS
#----------------------------------------
case $NM_SYSTEM in
	Darwin|Linux)
		nm_feature="alloca fn"
		nm_feature_name="nm_have_alloca_fn"
		nm_feature_run=yes
		nm_feature_h='#include <alloca.h>'
		nm_feature_flags=
		nm_feature_test='int *p=alloca(16*sizeof(*p));
                     return !p;'
		. ${NORE_ROOT}/auto/feature
	  ;;
	WinNT)
		nm_feature="alloca fn"
		nm_feature_name="nm_have_alloca_fn"
		nm_feature_run=no
		nm_feature_h='#include <malloc.h>'
		nm_feature_flags=
		nm_feature_test='int *p=alloca(16*sizeof(*p));
                     return !p;'
		. ${NORE_ROOT}/auto/feature
	  ;;
	*)
	  ;;
esac


case $NM_SYSTEM in
	Darwin)
		nm_feature="malloc_size fn"
		nm_feature_name="nm_have_malloc_size_fn"
		nm_feature_run=no
		nm_feature_h='#include <malloc/malloc.h>
                  #include <stdlib.h>'
		nm_feature_flags=
		nm_feature_test='int *p=malloc(16*sizeof(*p));
                     malloc_size(p);
                     free(p);'
		. ${NORE_ROOT}/auto/feature
	  ;;
	Linux)
		nm_feature="malloc_size fn"
		nm_feature_name="nm_have_malloc_size_fn"
		nm_feature_run=no
		nm_feature_h='#include <malloc.h>
                  #include <stdlib.h>'
		nm_feature_flags=
		nm_feature_test='int *p=malloc(16*sizeof(*p));
                     malloc_usable_size(p);
                     free(p);'
		. ${NORE_ROOT}/auto/feature
	  ;;
	WinNT)
		nm_feature="malloc_size fn"
		nm_feature_name="nm_have_malloc_size_fn"
		nm_feature_run=no
		nm_feature_h='#include <malloc.h>'
		nm_feature_flags=
		nm_feature_test='int *p=malloc(16*sizeof(*p));
                     _msize(p);
                     free(p);'
		. ${NORE_ROOT}/auto/feature		
	  ;;
	*)
	  ;;
esac

case "$NM_SYSTEM" in
	Darwin|Linux)
		nm_feature="aligned_alloc fn"
		nm_feature_name="nm_have_aligned_alloc_fn"
		nm_feature_run=no
		nm_feature_h='#include <stdlib.h>'
		nm_feature_flags="${nm_std_opt} ${nm_error_opt}"
		nm_feature_test='void *p = aligned_alloc(1024, 4096); 
                     return !p;'
		. ${NORE_ROOT}/auto/feature

		if [ "yes" != $nm_found ]; then
			nm_feature="posix_memalign fn"
			nm_feature_name="nm_have_posix_memalign_fn"
			nm_feature_run=no
			nm_feature_h='#include <stdlib.h>'
			nm_feature_flags=
			nm_feature_test='void *p; int n = posix_memalign(&p, 4096, 4096);
                       return n;'
			. ${NORE_ROOT}/auto/feature
		fi
		;;
	WinNT)
		nm_feature="memalign fn"
		nm_feature_name="nm_have_memalign_fn"
		nm_feature_run=no
		nm_feature_h=' #include <malloc.h>'
		nm_feature_flags=
		nm_feature_test='void *p = _aligned_malloc(1024, 4096);
                     return !p;'
		. ${NORE_ROOT}/auto/feature
		;;
esac

case "$CC_NAME" in
	clang)
		nm_feature="$CC_NAME typeof operator"
		nm_feature_name='nm_have_typeof'
		nm_feature_run=no
		nm_feature_h=
		nm_feature_flags=
		nm_feature_test='int x = 0x1122; __typeof(x) y = 0x3344'
		. ${NORE_ROOT}/auto/feature
		;;
	gcc)
		nm_feature="$CC_NAME typeof operator"
		nm_feature_name='nm_have_typeof'
		nm_feature_run=no
		nm_feature_h=
		nm_feature_flags=
		nm_feature_test='int x = 0x1122; typeof(x) y = 0x3344'
		. ${NORE_ROOT}/auto/feature
		;;
	msvc)
		nm_feature="$CC_NAME typeof operator"
		nm_feature_name='nm_have_typeof'
		nm_feature_run=no
		nm_feature_h=
		nm_feature_flags=
		nm_feature_test='int x = 0x1122; decltype(x) y = 0x3344'
		. ${NORE_ROOT}/auto/feature
		;;
esac


nm_feature="restrict keyword"
nm_feature_name="nm_have_restrict_keyword"
nm_feature_run=
nm_feature_h=
nm_feature_flags=
nm_feature_test='int x = 0x11; int *restrict p = &x;'
. ${NORE_ROOT}/auto/feature

if [ "yes" != $nm_found ]; then
	nm_feature="__restrict keyword"
	nm_feature_name="nm_have___restrict_keyword"
	nm_feature_run=
	nm_feature_h=
	nm_feature_flags=
	nm_feature_test='int x = 0x11; int *__restrict p = &x;'
	. ${NORE_ROOT}/auto/feature
fi

# check compiler features
#----------------------------------------
case "$CC_NAME" in
   gcc|clang)
     nm_feature="$CC_NAME -fsanitize=address"
     nm_feature_name=
     nm_feature_indent=yes
     nm_feature_run=no
     nm_feature_h=
     nm_feature_flags='-fsanitize=address'
     nm_feature_test=
     . ${NORE_ROOT}/auto/feature
     if [ yes = $nm_found ]; then
       flag=cflags_sanitize op="+=" value=$nm_feature_flags \
           . ${NORE_ROOT}/auto/make_define
     fi
     nm_feature="$CC_NAME -fsanitize=leak"
     nm_feature_name=
     nm_feature_indent=yes
     nm_feature_run=no
     nm_feature_h=
     nm_feature_flags='-fsanitize=leak'
     nm_feature_test=
     . ${NORE_ROOT}/auto/feature
     if [ yes = $nm_found ]; then
       flag=cflags_sanitize op="+=" value=$nm_feature_flags \
           . ${NORE_ROOT}/auto/make_define
     fi
     ;;		 
   msvc)
     ;;
esac


# EOF
